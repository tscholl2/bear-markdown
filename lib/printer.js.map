{"version":3,"file":"printer.js","sourceRoot":"","sources":["../src/printer.ts"],"names":[],"mappings":";;AASA,oBAA2B,QAAqC;IAC9D,MAAM,CAAC,eAAe,IAAiB,EAAE,KAAU;QAAV,sBAAA,EAAA,UAAU;QACjD,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,IAAI;YAClB,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxC,MAAM,IAAI,KAAK,CAAC,yBAAuB,IAAI,CAAC,IAAM,CAAC,CAAC;YACtD,CAAC;YACD,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AATD,gCASC","sourcesContent":["import { Node } from \"./parser\";\n\n/**\n * A Printer determines how to output a certain type node.\n */\nexport interface Printer<N = Node, S = {}, T = any> {\n  (node: N, output: (node: Array<N>, state?: S) => Array<T>, state: S): T;\n}\n\nexport function newPrinter(printers: { [type: string]: Printer }) {\n  return function print(tree: Array<Node>, state = {}): any[] {\n    return tree.map(node => {\n      if (!printers.hasOwnProperty(node.type)) {\n        throw new Error(`no printer for type ${node.type}`);\n      }\n      return printers[node.type](node, print, state);\n    });\n  };\n}\n"]}