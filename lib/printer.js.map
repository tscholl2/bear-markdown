{"version":3,"file":"printer.js","sourceRoot":"","sources":["../src/printer.ts"],"names":[],"mappings":";;AASA,oBAA2B,QAAuC;IAChE,IAAM,MAAM,GAAU,EAAE,CAAC;IACzB,eAAe,IAAiB,EAAE,KAAU;QAAV,sBAAA,EAAA,UAAU;QAC1C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,IAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxC,MAAM,IAAI,KAAK,CAAC,yBAAuB,IAAI,CAAC,IAAM,CAAC,CAAC;YACtD,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;QACvD,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IACD,MAAM,CAAC,KAAK,CAAC;AACf,CAAC;AAbD,gCAaC","sourcesContent":["import { Node } from \"./parser\";\n\n/**\n * A PrintRule determines how to output a certain type node.\n */\nexport interface PrintRule<N = Node, S = {}, T = any> {\n  (node: N, state: S, output: (node: Array<N>, state?: S) => Array<T>): T;\n}\n\nexport function newPrinter(printers: { [type: string]: PrintRule }) {\n  const output: any[] = [];\n  function print(tree: Array<Node>, state = {}) {\n    for (let i = 0; i < tree.length; i++) {\n      const node = tree[i];\n      if (!printers.hasOwnProperty(node.type)) {\n        throw new Error(`no printer for type ${node.type}`);\n      }\n      output.push(printers[node.type](node, state, print));\n    }\n    return output;\n  }\n  return print;\n}\n"]}