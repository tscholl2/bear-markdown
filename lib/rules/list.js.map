{"version":3,"file":"list.js","sourceRoot":"","sources":["../../src/rules/list.ts"],"names":[],"mappings":"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","sourcesContent":["import { Rule } from \"../parser\";\n\nconst listItemRE = new RegExp(\n  // a list item can start with an arbitrary indent\n  \"^( *)\" +\n    // followed by a bullet\n    \"([\\\\*\\\\-\\\\+]|\\\\d+\\\\.)\" +\n    // followed by a space\n    \" \" +\n    // followed by anything\n    \"([\\\\s\\\\S]*?)\" +\n    // until EOF, 2 newlines, or the same indent and a bullet\n    \"(?=$|\\\\n\\\\n|\\\\n\\\\1(?:[\\\\*\\\\-\\\\+]|\\\\d+\\\\.))\",\n);\n\nexport default <Rule<{ inline: boolean; _list?: boolean }>>{\n  order: 7,\n  match: (source, { inline, _list }, previousMatch) => {\n    // all list items must begin on a new line\n    if (previousMatch && !previousMatch.endsWith(\"\\n\")) {\n      return;\n    }\n    // if we are inside a list and previous match is empty, then we are not on a newline\n    // so we return. That is: \"1. * a\" is not a list in a list\n    if (_list && previousMatch === \"\") {\n      return;\n    }\n    // a list must be either a new block or inline inside a list (e.g. a sublist)\n    if (inline && !_list) {\n      return;\n    }\n    let match = \"\";\n    const items = [];\n    // while there is another list item\n    while (listItemRE.test(source)) {\n      // capture is of the form:\n      // [\n      //   full match,\n      //   indent,\n      //   bullet,\n      //   item content,\n      // TODO: add in pre-item stuff to know if was preceded by \\n\\n, or just \\n\n      // ]\n      const capture = listItemRE.exec(source)!;\n      match += capture[0];\n      source = source.substr(capture[0].length);\n      // if we saw 2 newlines and there is another list item (with the same indent),\n      // then skip over the newlines\n      if (source.startsWith(\"\\n\\n\") && listItemRE.test(source.substr(2))) {\n        match += \"\\n\\n\";\n        source = source.substr(2);\n      }\n      // same for 1 newline\n      if (source.startsWith(\"\\n\") && listItemRE.test(source.substr(1))) {\n        match += \"\\n\";\n        source = source.substr(1);\n      }\n      items.push(capture);\n    }\n    if (items.length === 0) {\n      return;\n    }\n    return [match, ...items];\n  },\n  parse: (capture, parse, state) => {\n    return {\n      type: \"list\",\n      bullet: capture[1][2],\n      items: capture.slice(1).map(item => {\n        let content = item[3]\n          // remove all indents on each line\n          .replace(new RegExp(`^${item[1]}`, \"gm\"), \"\");\n        const containsBlock = content.includes(\"\\n\\n\");\n        content = content.trim() + (containsBlock ? \"\\n\\n\" : \"\");\n        return parse(content, Object.assign({}, state, { inline: !containsBlock, _list: true }));\n      }),\n    };\n  },\n};\n"]}