{"version":3,"file":"text.js","sourceRoot":"","sources":["../../src/rules/text.ts"],"names":[],"mappings":";;AAEA,yDAAyD;AACzD,sDAAsD;AACtD,gDAAgD;AAChD,8DAA8D;AAC9D,2BAA2B;AAC3B,sDAAsD;AACtD,IAAM,EAAE,GAAG,8CAA8C,CAAC;AAE1D,kBAAqB;IACnB,KAAK,EAAE,UAAC,CAAC,EAAE,EAAU;YAAR,kBAAM;QAAO,OAAA,CAAC,MAAM,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;IAA5B,CAA4B;IACtD,KAAK,EAAE,UAAA,OAAO,IAAI,OAAA,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAlD,CAAkD;CACrE,CAAC","sourcesContent":["import { Rule } from \"../parser\";\n\n// This is taken from the text rule from simple-markdown.\n// It takes at least one letter (that isn't a newline)\n// and keep going until we get to something that\n// might possibly match something else (image, emphasis, etc.)\n// or the end of the match.\n// TODO: explain this regexp and what \\u00c0-\\uffff is\nconst re = /^[^\\n]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n|$)/;\n\nexport default <Rule>{\n  match: (s, { inline }) => (inline ? re.exec(s) : null),\n  parse: capture => ({ type: \"text\", props: { content: capture[0] } }),\n};\n"]}