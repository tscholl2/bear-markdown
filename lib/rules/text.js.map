{"version":3,"file":"text.js","sourceRoot":"","sources":["../../src/rules/text.ts"],"names":[],"mappings":";;AAEA,kBAAqB;IACnB,KAAK,EAAE,UAAC,CAAC,EAAE,EAAU;YAAR,kBAAM;QACjB,yDAAyD;QACzD,sDAAsD;QACtD,gDAAgD;QAChD,8DAA8D;QAC9D,2BAA2B;QAC3B,4BAA4B;QAC5B,OAAA,MAAM,GAAG,8CAA8C,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;IAAtE,CAAsE;IACxE,KAAK,EAAE,UAAA,OAAO,IAAI,OAAA,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAlD,CAAkD;CACrE,CAAC","sourcesContent":["import { Rule } from \"../parser\";\n\nexport default <Rule>{\n  match: (s, { inline }) =>\n    // This is taken from the text rule from simple-markdown.\n    // It takes at least one letter (that isn't a newline)\n    // and keep going until we get to something that\n    // might possibly match something else (image, emphasis, etc.)\n    // or the end of the match.\n    // TODO: explain this regexp\n    inline ? /^[^\\n]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n|$)/.exec(s) : null,\n  parse: capture => ({ type: \"text\", props: { content: capture[0] } }),\n};\n"]}