{"version":3,"file":"parser.js","sourceRoot":"","sources":["../src/parser.ts"],"names":[],"mappings":";;AA6BA;;;;GAIG;AACH,mBAA0B,KAAa;IACrC,IAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CACtB,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAApE,CAAoE,CAC/E,CAAC;IACF,oEAAoE;IACpE,IAAM,KAAK,GAAG,UAAS,MAAc,EAAE,KAAU;QAAV,sBAAA,EAAA,UAAU;QAC/C,IAAM,MAAM,GAAG,EAAE,CAAC;QAClB,IAAI,eAAe,GAAG,EAAE,CAAC;QACzB,OAAO,MAAM,EAAE,CAAC;YACd,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACtC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,IAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;gBAC3D,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;oBACZ,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;oBAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;oBAC/C,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACxB,MAAM,CAAC,IAAI,OAAX,MAAM,EAAS,IAAI,EAAE;oBACvB,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;wBACxB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACpB,CAAC;oBACD,eAAe,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC7B,KAAK,CAAC;gBACR,CAAC;gBACD,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3B,MAAM,IAAI,KAAK,CAAC,wCAAwC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;gBACrF,CAAC;YACH,CAAC;QACH,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC,CAAC;IACF,MAAM,CAAC,KAAK,CAAC;AACf,CAAC;AA/BD,8BA+BC","sourcesContent":["/**\n * A rule determines how to match and parse content.\n * The order determines which rules go first (lower goes first).\n * If no order is given, it is assumed to be 0.\n */\nexport interface Rule<S extends {} = { inline?: boolean }> {\n  order?: number;\n  match(source: string, state: Readonly<S>, previousMatch: string): undefined | null | RuleCapture;\n  parse(\n    capture: RuleCapture,\n    recusiveParse: (source: string, state: Readonly<S>) => undefined | Node | Array<Node>,\n    state: S,\n  ): undefined | Node | Array<Node>;\n}\n\n/**\n * Either undefined/null or an array of the form\n * [\n *  0: full string of characters matched\n *  1...n: capture groups available to the parse rule \n * ]\n */\nexport type RuleCapture = RegExpExecArray | Array<string>;\n/**\n * Nodes in the AST are plain objects with at least a key: \"type\" declaring what\n * kind of node they are.\n */\nexport type Node = { type: string };\n\n/**\n * A parser-creator.\n * @param Rules A map of rules to use.\n * @returns {function} A function which parses content. \n */\nexport function newParser(Rules: Rule[]) {\n  const rules = Rules.sort(\n    (a, b) => (a.order === b.order ? 0 : (a.order || 0) > (b.order || 0) ? 1 : -1),\n  );\n  // TODO: preparse source to remove any stupid stuff? (line endings?)\n  const parse = function(source: string, state = {}) {\n    const result = [];\n    let previousCapture = \"\";\n    while (source) {\n      for (let i = 0; i < rules.length; i++) {\n        const rule = rules[i];\n        const capture = rule.match(source, state, previousCapture);\n        if (capture) {\n          source = source.substring(capture[0].length);\n          const node = rule.parse(capture, parse, state);\n          if (Array.isArray(node)) {\n            result.push(...node);\n          } else if (node != null) {\n            result.push(node);\n          }\n          previousCapture = capture[0];\n          break;\n        }\n        if (i === rules.length - 1) {\n          throw new Error(\"could not find rule to match content: \" + JSON.stringify(source));\n        }\n      }\n    }\n    return result;\n  };\n  return parse;\n}\n"]}