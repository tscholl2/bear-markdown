declare module "tape" {
  export interface ITest {
    /**
     * Declare that n assertions should be run. t.end() will be called automatically after the nth assertion. If there are any more assertions after the nth, or after t.end() is called, they will generate errors.
     */
    plan(n: number): void;
    /**
     * Declare the end of a test explicitly. If err is passed in t.end will assert that it is falsey.
     */
    end(err?: any): void;
    /**
     * Generate a failing assertion with a message msg.
     */
    fail(msg?: string): void;
    /**
     * Generate a passing assertion with a message msg.
     */
    pass(msg?: string): void;
    /**
     * Automatically timeout the test after X ms.
     */
    timeoutAfter(ms: number): void;
    /**
     * Generate an assertion that will be skipped over.
     */
    skip(msg?: string): void;
    /**
     * Assert that value is truthy with an optional description of the assertion msg.
     * Aliases: t.true(), t.assert()
     */
    ok(value: any, msg?: string): void;
    /**
     * Assert that value is falsy with an optional description of the assertion msg.
     * Aliases: t.false(), t.notok()
     */
    notOk(value: any, msg?: string): void;
    /**
     * Assert that err is falsy. If err is non-falsy, use its err.message as the description message.
     * Aliases: t.ifError(), t.ifErr(), t.iferror()
     */
    error(err: any, msg?: string): void;
    /**
     * Assert that actual === expected with an optional description of the assertion msg.
     * Aliases: t.equals(), t.isEqual(), t.is(), t.strictEqual(), t.strictEquals()
     */
    equal(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that actual !== expected with an optional description of the assertion msg.
     * Aliases: t.notEquals(), t.notStrictEqual(), t.notStrictEquals(), t.isNotEqual(), t.isNot(), t.not(), t.doesNotEqual(), t.isInequal()
     */
    notEqual(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that actual and expected have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description of the assertion msg.
     * Aliases: t.deepEquals(), t.isEquivalent(), t.same()
     */
    deepEqual(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that actual and expected do not have the same structure and nested values using node's deepEqual() algorithm with strict comparisons (===) on leaf nodes and an optional description of the assertion msg.
     * Aliases: t.notEquivalent(), t.notDeeply(), t.notSame(), t.isNotDeepEqual(), t.isNotDeeply(), t.isNotEquivalent(), t.isInequivalent()
     */
    notDeepEqual(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that actual and expected have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description of the assertion msg.
     * Aliases: t.looseEqual(), t.looseEquals()
     */
    deepLooseEqual(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that actual and expected do not have the same structure and nested values using node's deepEqual() algorithm with loose comparisons (==) on leaf nodes and an optional description of the assertion msg.
     * Aliases: t.notLooseEqual(), t.notLooseEquals()
     */
    notDeepLooseEqual(actual: any, expected: any, msg?: string): void;
    /**
     * Assert that the function call fn() throws an exception. expected, if present, must be a RegExp or Function. The RegExp matches the string representation of the exception, as generated by err.toString(). The Function is the exception thrown (e.g. Error). msg is an optional description of the assertion.
     */
    throws(fn: () => void, expected: RegExp | ((e: any) => boolean), msg?: string): void;
    /**
     * Assert that the function call fn() does not throw an exception. msg is an optional description of the assertion.
     */
    doesNotThrow(fn: () => void, expected: RegExp | ((e: any) => boolean), msg?: string): void;
    /**
     * Create a subtest with a new test handle st from cb(st) inside the current test t. cb(st) will only fire when t finishes. Additional tests queued up after t will not be run until all subtests finish.
     */
    test(name: string, options?: any, cb?: () => void): void;
    /**
     * Print a message without breaking the tap output. (Useful when using e.g. tap-colorize where output is buffered & console.log will print in incorrect order vis-a-vis tap output.)
     */
    comment(msg: string): void;
  }
  export function test(fn: (t: ITest) => void): void;
  export function test(name: string, fn: (t: ITest) => void): void;
  export function test(name: string, options: any, fn: (t: ITest) => void): void;
}
